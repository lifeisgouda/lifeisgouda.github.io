<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Fourier Dev</title>
    <link>https://lifeisgouda.github.io/categories/algorithms/</link>
    <description>Recent content in algorithms on Fourier Dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>fourierdev</copyright>
    <lastBuildDate>Sat, 31 Mar 2018 23:49:58 +0900</lastBuildDate><atom:link href="https://lifeisgouda.github.io/categories/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Algorithms] BFS(Breadth-First Search 너비우선탐색)</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-03-01-bfs/</link>
      <pubDate>Sat, 31 Mar 2018 23:49:58 +0900</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-03-01-bfs/</guid>
      <description>Graph Algorithms shortest-path problem(최단경로 문제)을 해결할 때 사용한다.
순서  문제를 그래프로 모형화 너비 우선탐색으로 문제 해결  그래프 연결 집합을 모형화한 것을 그래프라고 한다.
node와 edge로 이루어져 있다.
출처 : http://mathworld.wolfram.com/GraphEdge.html
너비우선탐색 개념 그래프 전체를 탐색하는 방법 중 하나이다. 너비우선탐색, 깊이우선탐색이 있다.
Facebook에서 연결되는 사람(촌) 중에 과자 회사에 다니고 있는 사람이 있는지 찾으려고 한다고 가정해보자.
A는 시작점인 &amp;lsquo;나&amp;rsquo;자신이고, B, C, D는 1촌, E, F, G, H는 2촌, I, J, K는 3촌이 된다.</description>
    </item>
    
    <item>
      <title>[Data Structure] JavaScript Stack 구현</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-08-19-stack-javascript/</link>
      <pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-08-19-stack-javascript/</guid>
      <description>Stack 구현 1function Stack(){ 2 let items = []; 3 4 this.push = function(element) { 5 items.push(element); 6 }; 7 8 this.pop = function() { 9 return items.pop(); 10 }; 11 12 this.peek = function() { 13 return items[items.length-1]; 14 }; 15 16 this.isEmpty = function(){ 17 return items.length === 0; 18 }; 19 20 this.size = function(){ 21 return items.length; 22 }; 23 24 this.clear = function(){ 25 items = []; 26 }; 27 28 this.</description>
    </item>
    
    <item>
      <title>[Algorithms] 1. Two Sum</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-02-14-leetcode_1_two_sum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-02-14-leetcode_1_two_sum/</guid>
      <description>https://leetcode.com/problems/two-sum/description/
 Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
주어진 정수 배열을 이용하여, 임의의 두 수 합계가 타겟(target) 값이 되는 두 숫자의 인덱스를 반환해라.
각 입력에는 정확히 하나의 솔루션이 있다고 가정 할 수 있으며, 동일한 원소를 두 번 사용할 수 없다.</description>
    </item>
    
    <item>
      <title>[Algorithms] 7. Reverse Integer</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-02-21-leetcode_7_reverse_integer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-02-21-leetcode_7_reverse_integer/</guid>
      <description>[LeetCode] 7. Reverse Integer https://leetcode.com/problems/two-sum/description/
 Given a 32-bit signed integer, reverse digits of an integer.
주어진 32비트의 부호있는 정수의 자릿 수를 뒤집는 문제.
Example 1:
Input: 123 Output: 321 Example 2:
Input: -123 Output: -321 Example 3:
Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</description>
    </item>
    
    <item>
      <title>[Algorithms] 807.Max Increase to Keep City Skyline</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-04-09-leetcode_807/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-04-09-leetcode_807/</guid>
      <description>807.Max Increase to Keep City Skyline 문제  In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there.
2차원 배열 그리드(grid)에서, 각각의 grid[i][j] 값은 그곳에 위치한 건물의 높이를 나타낸다.
We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.
우리는 임의의 수의 건물 높이를 어느정도 증가시킬 수 있다(정도는 건물마다 다를 수 있다).</description>
    </item>
    
    <item>
      <title>[Algorithms] 9. Palindrome Number</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-02-28-leetcode_9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-02-28-leetcode_9/</guid>
      <description>[LeetCode] 9. Palindrome Number  Determine whether an integer is a palindrome. Do this without extra space.
주어진 정수가 회문인지 판단하라. 공백은 고려하지 않는다.
 Approch 1. Palindrome 회문이란 앞에서 부터 읽을 때와 뒤에서 부터 읽을 때가 같은 문장을 말한다
(ex) LEVEL, 12321, 다시합창합시다,
여기서는 공백은 고려하지 않는다.
2. Idea 숫자가 주어질 때 맨 앞과 맨 뒤부터 순차적으로 비교하면 회문인지 알 수 있다.
3. Solution 음수인지 아닌지 판단하고, 음수가 아니면 x를 뒤에서 부터 읽은 값과 x가 동일한지 판단한다.</description>
    </item>
    
    <item>
      <title>[Algorithms] FizzBuzz in Javascript</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-05-27-fizzbuzz_algorithm_in_javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-05-27-fizzbuzz_algorithm_in_javascript/</guid>
      <description>문제 3으로 나누어떨어지는 수일 때는 fizz, 5로 나누어떨어지는 수일 때는 buzz, 3과 5 둘 다 나누어떨어질 때는 fizzbuzz로 숫자를 대체한다.
Modulus Operator 나누어서 나머지를 출력해주는 연산자로 &amp;lsquo;%&amp;lsquo;를 사용할 수 있다.
1console.log(100%30); // 10 2console.log(7%3) // 1 Algorithm 먼저 문제를 해결할 function을 만든다.
1function fizzbuzz(num){} 예를들어, 20이 주어지면 결과가 1부터 20까지 출력되고, 위 조건의 숫자만 fizz, buzz, fizzbuzz로 대체 된다. 그러므로 1부터 20까지 출력될 수 있는 for문을 작성한다.
1function fizzbuzz(num){ 2 for(let i=1; i &amp;lt;= num; i++){ 3 /* each number which is represented by the variable i */ 4 } 5} num이나 i가 3으로 나누어 떨어지면 숫자 대신에 fizz, 5로 나누어 떨어지면 buzz, 3과 5 둘다 나누어 떨어지는 수이면 fizzbuzz가 출력되어야 한다.</description>
    </item>
    
    <item>
      <title>[Algorithms] Harmless Ransom Note in Javascript</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-06-04-harmless_ransom_note_in_javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-06-04-harmless_ransom_note_in_javascript/</guid>
      <description>문제 Harmless ransom note algorithm은 두개의 parameter를 갖는다.
첫번째 parameter인 noteText는 string과 같은 텍스트를 받을 수 있다. 두번째 parameter인 magazineText에도 string 같은 텍스트가 들어간다.
예를들어, 아래와 같이 note와 meagazine이 쓰여있다
 Note : &amp;rsquo;this si a secret note for you from a secret admirer.&#39;
  Magazine : &amp;lsquo;puerto rico is a great place you must hike far from town to find a secret waterfall that i am an admirer of but note that it is not as hard it seems this my advice for you&amp;rsquo;</description>
    </item>
    
    <item>
      <title>[Algorithms] LeetCode 189. Rotate Array</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-08-21-leetcode_189_rotate-array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-08-21-leetcode_189_rotate-array/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note:   Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</description>
    </item>
    
    <item>
      <title>[Algorithms] LeetCode 812. Largest Triangle Area</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-08-07-leetcode_812_largest_triangle_area/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-08-07-leetcode_812_largest_triangle_area/</guid>
      <description>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.
 비행기 좌표가 찍힌 목록이 있다. 임의의 3개의 점으로 그려질 수 있는 가장 큰 삼각형 면적을 반환해라.
 Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation: The five points are show in the figure below. The red triangle is the largest. 다섯개 점의 그림은 아래와 같다.</description>
    </item>
    
    <item>
      <title>[Algorithms] programmers: 2016년</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-09-10-programmers_2016/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-09-10-programmers_2016/</guid>
      <description>문제 설명 2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT
입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 TUE를 반환하세요.
제한 조건   2016년은 윤년입니다.
  2016년 a월 b일은 실제로 있는 날입니다. (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)
  입출력 예    a b result     5 24 TUE    풀이 Brute force Javscript 1// a는 월, b는 일 2// Date(2016, a - 1, b) 2016년, a-1월, b일 (0이 1월이므로 a에 -1) 3// getDay()는 요일 반환.</description>
    </item>
    
    <item>
      <title>[Algorithms] Two Fer</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2018-08-14-algorithms_two_fer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2018-08-14-algorithms_two_fer/</guid>
      <description>[Algorithms] Two Fer Introduction Two-fer or 2-fer is short for two for one. One for you and one for me.
&amp;#34;One for X, one for me.&amp;#34; When X is a name or &amp;ldquo;you&amp;rdquo;.
If the given name is &amp;ldquo;Alice&amp;rdquo;, the result should be &amp;ldquo;One for Alice, one for me.&amp;rdquo;
If no name is given, the result should be &amp;ldquo;One for you, one for me.&amp;rdquo;
Solutions 1var TwoFer = function () {}; 2 3TwoFer.</description>
    </item>
    
    <item>
      <title>[Data Structure] Circular Queue</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/2019-06-09-circular_queue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/2019-06-09-circular_queue/</guid>
      <description>python3로 Circular Queue 구현하기 __ init __() 먼저 데이터 구조의 초깃값을 정한다. Queue의 크기를 k로 두고, 값을 담을 수 있게 길이가 k인 리스트 queue_list 를 만든다.
Queue에는 두개의 포인터가 필요하다. 한개는 Front를 가리켜야 하고, 다른 하나는 Back을 가리켜야 한다.
1def __init__(self, k: int): 2 self.size = 0 # 처음 리스트의 길이 3 self.max_size = k # 리스트의 길이 4 self.queue_list = [0] * k # Queue를 담을 리스트 5 self.front = self.</description>
    </item>
    
    <item>
      <title>[Data Structure] Graph</title>
      <link>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-08-22-data_structure_graph/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://lifeisgouda.github.io/posts/algorithms/data_structure/2018-08-22-data_structure_graph/</guid>
      <description>정의 네트워크 구조를 추상화한 모델. 간선(edge)으로 연결된 노드(node)의 집합이다.
그래프에 대한 설명과 구현은 이 곳에 잘 나와있다.
http://blog.benoitvallon.com/data-structures-in-javascript/the-graph-data-structure/
그래프의 용어를 그림 하나로 정리해보면 아래와 같다.
동적 그래프 자료구조는 인접리스트(adjacency list)로 표현 가능하다.
위 그래프를 인접리스트로 나타낸 것이다.
 A : B C D
B : A E F
C : A D G
D : A C G H
E : B I
G : C D
H : D</description>
    </item>
    
  </channel>
</rss>
